
// :: EL VIAJE DE FRODO ::  Enero 2007
// Jose Alberto Benítez Andrades

{


}
PROGRAM EL_VIAJE_DE_FRODO;

CONST
	MAX    = 500;

	NADA   = 'NADA';
	PAN    = 'PAN';
	FRUTOS = 'FRUTOS';
	ORCO   = 'ORCO';

	NORTE  = 'NORTE';
	SUR    = 'SUR';
	ESTE   = 'ESTE';
	OESTE  = 'OESTE';


TYPE

        tMovimiento = word;
        tObjeto     = word;

	tEnergia     = word;
	tEstado      = (NORMAL, MAREADO);
	tTiempoMareo = word;

	tCasilla = record
                        movimiento : tMovimiento;
                        objeto     : tObjeto;
                   end;

	// Casilla donde se encuentra nuestro amigo Frodo
	tCasillaFrodo = record
				fila   : word;
				columna: word;
			 end;

	// Datos que afectan al pequeño Frodo
	tPersonaje = record
			energia      : tEnergia;
			estado       : tEstado;
			tiempoMareo  : tTiempoMareo;
			casilla      : tCasillaFrodo;
		     end;



	tFicheroLog = text;
	tTablero = array [1..MAX, 1..MAX] of tCasilla;


VAR
	filas	   : word;
	columnas   : word;
	tablero	   : tTablero;
	frodo      : tPersonaje;       { El pequeño Frodo }
	mensaje    : string;
	ficheroLog : tFicheroLog;

	movimientoActual : tMovimiento;
	objetoActual     : tObjeto;
	estadoActual     : tEstado;
        finPartida       : boolean;
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

FUNCTION verEstado(obj:tObjeto):string;
Var
	estadoActual	: string;
Begin
	case obj of
		0,1,3 : estadoActual:= 'NORMAL';
		2     : estadoActual:= 'MAREADO';
	end;

	verEstado:= estadoActual;
End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

FUNCTION verMovimiento(mov:tMovimiento):string;
Var
	nombreMov:string;
Begin
	case mov of
		0 : nombreMov:= 'NORTE';
		1 : nombreMov:= 'SUR';
		2 : nombreMov:= 'ESTE';
		3 : nombreMov:= 'OESTE';
	end;

	verMovimiento:= nombreMov;
End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

FUNCTION verObjeto(obj:tObjeto):string;
Var
	nombreObj:string;
Begin
	case obj of
		0 : nombreObj:= 'NADA';
		1 : nombreObj:= 'PAN';
		2 : nombreObj:= 'FRUTOS';
		3 : nombreObj:= 'ORCO';
	end;

	verObjeto:= nombreObj;
End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

PROCEDURE pedirDatosPrimarios(var N:word; var M:word;var e:tEnergia);
Begin
	repeat
        	write('Introduzca el numero de filas: ');
        	readln(N);
	until(N<=500) and (N>0);

	repeat
        	write('Introduzca el numero de columnas: ');
        	readln(M);
	until(M<=500) and (M>0);

        repeat
        	write('Introduzca la energía inicial de frodo: (MENOR A ', N*M, ')');
        	readln(e);
        until(e<=N*M);
End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

PROCEDURE pedirContenidoCasillas(N:word; M:word; var tablero:tTablero);

Var
        i:word;
        j:word;
Begin	
	writeln('MOVIMIENTOS => 0 - NORTE | 1 - SUR | 2 - ESTE | 3 - OESTE');
	writeln('OBJETOS => 0 - NADA | 1 - PAN | 2 - FRUTOS | 3 - ORCO');

        for i:=1 to N do
        	for j:=1 to M do
                        begin
                        	write('Introduzca la direccion para la casilla [',i,',',j,']: ');
                        	readln(tablero[i,j].movimiento);
                        	write('Introduzca el objeto [',i,',',j,']: ');
                        	readln(tablero[i,j].objeto);
                        end;

End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

PROCEDURE cambiaTiempoMareo(t: tTiempoMareo; obj: tObjeto);

Begin
	if (verObjeto(obj)='FRUTOS')
		then t := t + 5     // Si el objeto es un FRUTO ... aumentamos el tiempo de mareo
		else t := t - 1;    // Si no lo es ... disminuimos, no?
End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

PROCEDURE cambiaMovSiEsBorde(cf: tCasillaFrodo; var mov: string; N: word; M: word);

Begin
	case mov[1] of

		'N' :  // Movimiento al NORTE ...

			if (cf.fila = 1)   // ... ¡ en la PRIMERA FILA !
			then begin
				if (cf.columna = M)
					then mov:= 'SUR'      // Casilla [1, MAX]
					else mov:= 'ESTE';    // Casillas [1, 1]-[1,MAX-1]
			end;

		'S' : // Movimiento al SUR ...

			if (cf.fila = N) // ... ¡ en la ÚLTIMA FILA !
			then begin
				if (cf.columna = 1)
					then mov:= 'NORTE'    // Casilla [MAX, 1]
					else mov:= 'OESTE';   // Casillas [MAX, 2]-[MAX, MAX]
			end;

		'E' : // Movimiento al ESTE ...

			if (cf.columna = M) // ... ¡ en la ÚLTIMA COLUMNA !
			then begin
				if (cf.fila = N)
					then mov:= 'OESTE'   // Casilla [MAX, MAX]
					else mov:= 'SUR';    // Casillas [1, MAX]-[MAX-1, MAX-1]
			end;

		'O' : // Movimiento al OESTE ...

			if (cf.columna = 1) // ... ¡ en la ÚLTIMA COLUMNA !
			then begin
				if (cf.fila = 1)
					then mov:= 'ESTE'    // Casilla [1, 1]
					else mov:= 'NORTE';  // Casillas [2, 1]-[MAX-1, 1]
			end;
	end;

End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

PROCEDURE moverAFrodo(mv: tMovimiento; est: tEstado ; var cf: tCasillaFrodo; N : word; M: word);

Var
	mov : string;
Begin
	mov:= VerMovimiento(mv);  // Tomamos la cadena entera ...

	// Vemos si es una casilla "especial" por estar en los bordes, donde Frodo se mueve
	// según el sentido horario de las casillas del reloj ...

	cambiaMovSiEsBorde(cf, mov, N, M);

	if (est = NORMAL)
		then begin
			case mov[1] of   // ... pero sólo usamos la primera letra para el CASE

				'N' : cf.fila:= cf.fila - 1;       // NORTE = FILA ANTERIOR
				'S' : cf.fila:= cf.fila + 1;       // SUR   = FILA SIGUIENTE
				'E' : cf.columna:= cf.columna + 1; // ESTE  = COLUMNA SIGUIENTE
				'O' : cf.columna:= cf.columna - 1; // OESTE = COLUMNA ANTERIOR
			end;
		     end;

	if (est = MAREADO)
		then begin
			case mov[1] of

				'N' : cf.fila:= cf.fila + 1;       // NORTE =  SUR NORMAL
				'S' : cf.fila:= cf.fila - 1;       // SUR   =  NORTE NORMAL
				'E' : cf.columna:= cf.columna - 1; // ESTE  =  OESTE NORMAL
				'O' : cf.columna:= cf.columna + 1; // OESTE =  ESTE NORMAL

			end;
		     end;
End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

PROCEDURE calcularNivelEnergia(ob:tObjeto; est:tEstado; var energia:tEnergia);

Var
	obj    :string;
Begin
	obj:= VerObjeto(ob);
	if (est = NORMAL)
		then begin
			if (obj = NADA)
				then energia:= energia - 1
				else if (obj = PAN)
					then energia:= energia + 2
					else if(obj = ORCO)
						then energia:= energia - 1;
		     end;

	if (est = MAREADO)
		then begin
			if (obj = NADA)
				then energia:= energia - 2
				else if (obj = PAN)
					then energia:= energia + 2
					else if(obj = ORCO)
						then energia:= 0;
		     end;

End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

{ Este procedure es el que pienso que crea el log en un principio }
PROCEDURE crearLog(var log: tFicheroLog);

Begin
        Assign(log,'log.txt');
        Rewrite(log);
        Close(log);
End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

{ Y ahora una vez está creado hacemos que agregue las líneas correspondientes a los movimientos....
que es lo que veo algo más complicao porque no sé como ponerlo así de primeras... }

PROCEDURE escribeLog(var log: tFicheroLog; msj: string);
{ Recibe el fichero log que vamos a escribir y el nuevo mensaje.
  * MENSAJE --> [fila, columna] - DIRECCIÓN - ENERGÍA ACUMULADA }
Begin
        Assign(log,'log.txt'); //No creo que lo tengas que asignar otra vez, no?
	Append(log);
        //writeln(log,'[',cf.fila,',',cf.columna,'] - ',movimientoactual??,' - ',energia);
	writeln(log, msj);
        close(log);
end;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

FUNCTION  esFinDePartida(e : tEnergia; est: tEstado; ob: tObjeto; cf: tCasillaFrodo; N: word; M: word):boolean;

Var
	final : boolean;
Begin
        final := FALSE;

	if (e = 0)
		then begin
                        writeln('Frodo ha muerto por pérdida de energía');
		        final := TRUE;
                end

	else if (est = MAREADO) AND (verObjeto(ob) = ORCO)
		then begin
                        writeln('Frodo ha muerto a manos de un orco debido a su mareo');
	                final := TRUE;
                end

        else if (cf.fila = N) AND (cf.columna = M)
		then begin
                        writeln('Frodo ha llegado a Mordor y ha destruído el anillo');
	                final := TRUE;
                end;



        esFinDePartida := final;

End;

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

FUNCTION convertirEntero (entero : word):string;

Var
	caracter: string;
Begin
	str(entero, caracter);

	convertirEntero := caracter;


End;
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

{ Sé lo que quiero hacer, lo que pasa que no sé si está bien hecho para que coja justo en el momento
que ocurre cada cosa la energía... el movimiento... la fila... échale un vistazo y sino me preguntas
que entre los 2 se saca, lo que no he sabido llamar es al movimiento , lo de norte, sur, este... }

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

BEGIN

// Se inicializa

// Se crea el fichero log
crearLog(ficheroLog);

// Se piden los datos primarios : Filas/Columnas del tablero , Energía inicial Frodo
pedirDatosPrimarios(filas, columnas, frodo.energia);

// Ahora el contenido de las casillas
pedirContenidoCasillas(filas, columnas, tablero);

// Si las posiciones [1, 1] y [N, M] no están vacías, el programa muestra un error

if ((verObjeto(tablero[1,1].objeto) <> 'NADA') or (verObjeto(tablero[filas,columnas].objeto) <> 'NADA'))
	then begin
		writeln('ERROR : Las casillas [1, 1] y [',filas,', ',columnas,'] deben estar vacías de objetos');
		escribeLog(ficheroLog, 'ERROR'); // Esto es para probar ...
	     end
	else begin

		// Inicializamos los datos con los que Frodo comienza el recorrido
		frodo.casilla.fila    := 1;
		frodo.casilla.columna := 1;
		frodo.estado := NORMAL;
                finPartida := FALSE;

		// Frodo comienza el recorrido ...
		repeat
			// Movimiento y objeto de la casilla actual de Frodo
			movimientoActual := tablero[frodo.casilla.fila, frodo.casilla.columna].movimiento;
			objetoActual := tablero[frodo.casilla.fila, frodo.casilla.columna].objeto;

			// Se comprueba el estado de Frodo
			estadoActual := frodo.estado;

                        mensaje:= '[' + convertirEntero(frodo.casilla.fila) + ',' + convertirEntero(frodo.casilla.columna) + '] - ' + verMovimiento(movimientoActual) + ' - ' + convertirEntero(frodo.energia);
                	escribeLog(ficheroLog, 'mensaje');
			// Movemos a Frodo ...
			moverAFrodo(movimientoActual, estadoActual, frodo.casilla, filas, columnas);

			// Calculamos el nuevo nivel de energía
			calcularNivelEnergia(objetoActual, estadoActual, frodo.energia);

			// Cambiamos el tiempo que Frodo está mareado ...
			cambiaTiempoMareo(frodo.tiempoMareo, objetoActual);

			// Escribimos el fichero log con el mensaje correspondiente
			// El mensaje seria algo como lo que sigue ... pero hay que pasar antes los números a string...

			//mensaje:= verMovimiento(movimientoActual);


                       finPartida := esFinDePartida(frodo.energia,estadoActual,objetoActual,frodo.casilla,filas,columnas);
                until(finPartida = TRUE);
                //until (frodo.energia = 0);
                //until (esFinDePartida(frodo.energia,estadoActual,objetoActual,frodo.casilla,filas,columnas) = TRUE);


	end;

END.
